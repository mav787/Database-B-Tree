<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_65) on Thu Apr 03 22:49:43 EDT 2014 -->
<TITLE>
Node
</TITLE>

<META NAME="date" CONTENT="2014-04-03">

<LINK REL ="stylesheet" TYPE="text/css" HREF="stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Node";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="Main.html" title="class in &lt;Unnamed&gt;"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="Reference.html" title="class in &lt;Unnamed&gt;"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?Node.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
Class Node</H2>
<PRE>
java.lang.Object
  <IMG SRC="./resources/inherit.gif" ALT="extended by "><B>Node</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;">InternalNode</A>, <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;">LeafNode</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>Node</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Superclass of Leaf Nodes (LeafNode) and Internal Nodes (InternalNode)
   of B+-Trees.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>cs127b</DD>
</DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#myname">myname</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#alignPointers()">alignPointers</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#combinable(Node)">combinable</A></B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if this node can be combined with other into a new node without splitting.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#combine()">combine</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Combines the contents of this node and its next sibling (next)
       into a single node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#delete(int)">delete</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Delete the key and pointer at index i.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#deleteSimple(int)">deleteSimple</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deletes keys [i] and ptrs [i] from this node,
       without performing any combination or redistribution afterwards.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#findKeyIndex(int)">findKeyIndex</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find index i s.t.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#findPtrIndex(int)">findPtrIndex</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find index i s.t.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#full()">full</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the fullness state of this node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#getKey(int)">getKey</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the ith key of current node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#getLast()">getLast</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the last key index of the Node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#getNext()">getNext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the next node of current node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="Reference.html" title="class in &lt;Unnamed&gt;">Reference</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#getParent()">getParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the parent reference of current node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#getPrev()">getPrev</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the previous node of current node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#getPtr(int)">getPtr</A></B>(int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Get the ith pointer of current node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#insert(int, Node)">insert</A></B>(int&nbsp;val,
       <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;ptr)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The difference between
       <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> and <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A> is whether a split
       creates a <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> or <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>, and whether the split
       results in a duplicate key being inserted
       into parent or not.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#insertSimple(int, Node, int)">insertSimple</A></B>(int&nbsp;val,
             <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;ptr,
             int&nbsp;i)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Inserts (val, ptr) pair into this node
       at keys [i] and ptrs [i].</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#minkeys()">minkeys</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The minimum number of keys this node should have, which differs from <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> and 
       <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#outputForGraphviz()">outputForGraphviz</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#redistribute()">redistribute</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Redistributes keys and pointers in this node and its
       next slibing so that they have the same number of keys
       and pointers, or so that this node has one more key and
       one more pointer,.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="Reference.html" title="class in &lt;Unnamed&gt;">Reference</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#search(int)">search</A></B>(int&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equivalent to <A HREF="Node.html#findKeyIndex(int)"><CODE>findKeyIndex(int)</CODE></A> in <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> but calls
       itself recursively in <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#setNext(Node)">setNext</A></B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;n)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the next node to n</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#setParent(Reference)">setParent</A></B>(<A HREF="Reference.html" title="class in &lt;Unnamed&gt;">Reference</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the parent reference of current node</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#setPrev(Node)">setPrev</A></B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Set the previous node to p</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="Node.html#siblings(Node)">siblings</A></B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;other)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Checks whether two Node objects are siblings.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="myname"><!-- --></A><H3>
myname</H3>
<PRE>
public java.lang.String <B>myname</B></PRE>
<DL>
<DL>
</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="outputForGraphviz()"><!-- --></A><H3>
outputForGraphviz</H3>
<PRE>
public abstract void <B>outputForGraphviz</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getLast()"><!-- --></A><H3>
getLast</H3>
<PRE>
public int <B>getLast</B>()</PRE>
<DL>
<DD>Get the last key index of the Node.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the last key index</DL>
</DD>
</DL>
<HR>

<A NAME="getPtr(int)"><!-- --></A><H3>
getPtr</H3>
<PRE>
public <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A> <B>getPtr</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get the ith pointer of current node
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the index
<DT><B>Returns:</B><DD>the i_th node of current node</DL>
</DD>
</DL>
<HR>

<A NAME="getKey(int)"><!-- --></A><H3>
getKey</H3>
<PRE>
public int <B>getKey</B>(int&nbsp;i)</PRE>
<DL>
<DD>Get the ith key of current node
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the index
<DT><B>Returns:</B><DD>the i_th key of current node</DL>
</DD>
</DL>
<HR>

<A NAME="getNext()"><!-- --></A><H3>
getNext</H3>
<PRE>
public <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A> <B>getNext</B>()</PRE>
<DL>
<DD>Get the next node of current node
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a node which is next to this node, or null if this node is the last one of one level</DL>
</DD>
</DL>
<HR>

<A NAME="getPrev()"><!-- --></A><H3>
getPrev</H3>
<PRE>
public <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A> <B>getPrev</B>()</PRE>
<DL>
<DD>Get the previous node of current node
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a node which is right before this node, or null if this node is the first one of a level</DL>
</DD>
</DL>
<HR>

<A NAME="getParent()"><!-- --></A><H3>
getParent</H3>
<PRE>
public <A HREF="Reference.html" title="class in &lt;Unnamed&gt;">Reference</A> <B>getParent</B>()</PRE>
<DL>
<DD>Get the parent reference of current node
<P>
<DD><DL>

<DT><B>Returns:</B><DD>a reference which refers to the parend node, or null if this node is the root</DL>
</DD>
</DL>
<HR>

<A NAME="full()"><!-- --></A><H3>
full</H3>
<PRE>
public boolean <B>full</B>()</PRE>
<DL>
<DD>Returns the fullness state of this node
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this node is full, (has degree - 1 keys).</DL>
</DD>
</DL>
<HR>

<A NAME="siblings(Node)"><!-- --></A><H3>
siblings</H3>
<PRE>
public boolean <B>siblings</B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;other)</PRE>
<DL>
<DD>Checks whether two Node objects are siblings. 
        Two instances of Node are siblings if they are children of the same node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>other</CODE> - 
<DT><B>Returns:</B><DD>true if other's parent is the same as this's; otherwise false</DL>
</DD>
</DL>
<HR>

<A NAME="setParent(Reference)"><!-- --></A><H3>
setParent</H3>
<PRE>
public void <B>setParent</B>(<A HREF="Reference.html" title="class in &lt;Unnamed&gt;">Reference</A>&nbsp;l)</PRE>
<DL>
<DD>Set the parent reference of current node
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>l</CODE> - the parent reference</DL>
</DD>
</DL>
<HR>

<A NAME="setNext(Node)"><!-- --></A><H3>
setNext</H3>
<PRE>
public void <B>setNext</B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;n)</PRE>
<DL>
<DD>Set the next node to n
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>n</CODE> - the new next node</DL>
</DD>
</DL>
<HR>

<A NAME="setPrev(Node)"><!-- --></A><H3>
setPrev</H3>
<PRE>
public void <B>setPrev</B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;p)</PRE>
<DL>
<DD>Set the previous node to p
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - the new previous node</DL>
</DD>
</DL>
<HR>

<A NAME="findKeyIndex(int)"><!-- --></A><H3>
findKeyIndex</H3>
<PRE>
public int <B>findKeyIndex</B>(int&nbsp;val)</PRE>
<DL>
<DD>Find index i s.t. keys [i] == val, or if val
       were to be inserted, keys [i] is where it should
       be placed.  More formally, returns i s.t.
       keys [i-1] < val <= keys [i], or 
       lastindex if val >= keys [lastindex]
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>val</CODE> - the value to find
<DT><B>Returns:</B><DD>the index of the key where val should be</DL>
</DD>
</DL>
<HR>

<A NAME="findPtrIndex(int)"><!-- --></A><H3>
findPtrIndex</H3>
<PRE>
public int <B>findPtrIndex</B>(int&nbsp;val)</PRE>
<DL>
<DD>Find index i s.t. ptrs [i] is the pointer that
       should be followed in the search for val.  More
       formally, returns i s.t.
       keys [i] <= val < keys [i + 1]
       or 0, if val < keys [1].  Note, cannot compute
       this result by incrementing or decrementing
       result of findKeyIndex
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>val</CODE> - 
<DT><B>Returns:</B><DD>the index of pointer that we should follow in order to find val</DL>
</DD>
</DL>
<HR>

<A NAME="delete(int)"><!-- --></A><H3>
delete</H3>
<PRE>
public void <B>delete</B>(int&nbsp;i)</PRE>
<DL>
<DD>Delete the key and pointer at index i.  Combine or
       redistribute nodes if necessary to preserve order of node.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the index of key and pointer to delete</DL>
</DD>
</DL>
<HR>

<A NAME="alignPointers()"><!-- --></A><H3>
alignPointers</H3>
<PRE>
public void <B>alignPointers</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="minkeys()"><!-- --></A><H3>
minkeys</H3>
<PRE>
public abstract int <B>minkeys</B>()</PRE>
<DL>
<DD>The minimum number of keys this node should have, which differs from <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> and 
       <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the mininal number of key</DL>
</DD>
</DL>
<HR>

<A NAME="combinable(Node)"><!-- --></A><H3>
combinable</H3>
<PRE>
public abstract boolean <B>combinable</B>(<A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;other)</PRE>
<DL>
<DD>Check if this node can be combined with other into a new node without splitting.
       Return TRUE if this node and other can be combined.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>true if this node can be combined with other; otherwise false.</DL>
</DD>
</DL>
<HR>

<A NAME="combine()"><!-- --></A><H3>
combine</H3>
<PRE>
public abstract void <B>combine</B>()</PRE>
<DL>
<DD>Combines the contents of this node and its next sibling (next)
       into a single node
<P>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="redistribute()"><!-- --></A><H3>
redistribute</H3>
<PRE>
public abstract int <B>redistribute</B>()</PRE>
<DL>
<DD>Redistributes keys and pointers in this node and its
       next slibing so that they have the same number of keys
       and pointers, or so that this node has one more key and
       one more pointer,.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the key that must be inserted into parent node</DL>
</DD>
</DL>
<HR>

<A NAME="insertSimple(int, Node, int)"><!-- --></A><H3>
insertSimple</H3>
<PRE>
public abstract void <B>insertSimple</B>(int&nbsp;val,
                                  <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;ptr,
                                  int&nbsp;i)</PRE>
<DL>
<DD>Inserts (val, ptr) pair into this node
       at keys [i] and ptrs [i].  Called when this
       node is not full.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>val</CODE> - the value to insert<DD><CODE>ptr</CODE> - the pointer to insert<DD><CODE>i</CODE> - the index where the key and pointer should be</DL>
</DD>
</DL>
<HR>

<A NAME="deleteSimple(int)"><!-- --></A><H3>
deleteSimple</H3>
<PRE>
public abstract void <B>deleteSimple</B>(int&nbsp;i)</PRE>
<DL>
<DD>Deletes keys [i] and ptrs [i] from this node,
       without performing any combination or redistribution afterwards.
       It is done by shifting all keys and pointers from index i+1 on
       one position to the left.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>i</CODE> - the index of key and pointer to delete</DL>
</DD>
</DL>
<HR>

<A NAME="search(int)"><!-- --></A><H3>
search</H3>
<PRE>
public abstract <A HREF="Reference.html" title="class in &lt;Unnamed&gt;">Reference</A> <B>search</B>(int&nbsp;val)</PRE>
<DL>
<DD>Equivalent to <A HREF="Node.html#findKeyIndex(int)"><CODE>findKeyIndex(int)</CODE></A> in <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> but calls
       itself recursively in <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the reference where the key should be</DL>
</DD>
</DL>
<HR>

<A NAME="insert(int, Node)"><!-- --></A><H3>
insert</H3>
<PRE>
public abstract void <B>insert</B>(int&nbsp;val,
                            <A HREF="Node.html" title="class in &lt;Unnamed&gt;">Node</A>&nbsp;ptr)</PRE>
<DL>
<DD>The difference between
       <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> and <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A> is whether a split
       creates a <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A> or <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>, and whether the split
       results in a duplicate key being inserted
       into parent or not.  (For <A HREF="LeafNode.html" title="class in &lt;Unnamed&gt;"><CODE>LeafNode</CODE></A>, yes.  For
       <A HREF="InternalNode.html" title="class in &lt;Unnamed&gt;"><CODE>InternalNode</CODE></A>, no.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>val</CODE> - the value to insert<DD><CODE>ptr</CODE> - the pointer to insert</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/Node.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="Main.html" title="class in &lt;Unnamed&gt;"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="Reference.html" title="class in &lt;Unnamed&gt;"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="index.html?Node.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="Node.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
